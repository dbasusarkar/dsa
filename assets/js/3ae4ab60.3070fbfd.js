"use strict";(self.webpackChunkdsa=self.webpackChunkdsa||[]).push([[3629],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),o=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=o(e.components);return a.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,u=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=o(n),d=r,h=m["".concat(u,".").concat(d)]||m[d]||p[d]||i;return n?a.createElement(h,s(s({ref:t},c),{},{components:n})):a.createElement(h,s({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=m;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l.mdxType="string"==typeof e?e:r,s[1]=l;for(var o=2;o<i;o++)s[o]=n[o];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(7294),r=n(6010);const i="tabItem_Ymn6";function s(e){let{children:t,hidden:n,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(i,s),hidden:n},t)}},5488:(e,t,n)=>{n.d(t,{Z:()=>d});var a=n(7462),r=n(7294),i=n(6010),s=n(2389),l=n(7392),u=n(7094),o=n(2466);const c="tabList__CuJ",p="tabItem_LNqP";function m(e){var t;const{lazy:n,block:s,defaultValue:m,values:d,groupId:h,className:g}=e,k=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),b=d??k.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),S=(0,l.l)(b,((e,t)=>e.value===t.value));if(S.length>0)throw new Error(`Docusaurus error: Duplicate values "${S.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const y=null===m?m:m??(null==(t=k.find((e=>e.props.default)))?void 0:t.props.value)??k[0].props.value;if(null!==y&&!b.some((e=>e.value===y)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${y}" but none of its children has the corresponding value. Available values are: ${b.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:v,setTabGroupChoices:f}=(0,u.U)(),[x,w]=(0,r.useState)(y),O=[],{blockElementScrollPositionUntilNextRender:E}=(0,o.o5)();if(null!=h){const e=v[h];null!=e&&e!==x&&b.some((t=>t.value===e))&&w(e)}const N=e=>{const t=e.currentTarget,n=O.indexOf(t),a=b[n].value;a!==x&&(E(t),w(a),null!=h&&f(h,String(a)))},j=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=O.indexOf(e.currentTarget)+1;n=O[t]??O[0];break}case"ArrowLeft":{const t=O.indexOf(e.currentTarget)-1;n=O[t]??O[O.length-1];break}}null==(t=n)||t.focus()};return r.createElement("div",{className:(0,i.Z)("tabs-container",c)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":s},g)},b.map((e=>{let{value:t,label:n,attributes:s}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:x===t?0:-1,"aria-selected":x===t,key:t,ref:e=>O.push(e),onKeyDown:j,onFocus:N,onClick:N},s,{className:(0,i.Z)("tabs__item",p,null==s?void 0:s.className,{"tabs__item--active":x===t})}),n??t)}))),n?(0,r.cloneElement)(k.filter((e=>e.props.value===x))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},k.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==x})))))}function d(e){const t=(0,s.Z)();return r.createElement(m,(0,a.Z)({key:String(t)},e))}},732:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>u,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var a=n(7462),r=(n(7294),n(3905)),i=n(5488),s=n(5162);const l={sidebar_position:6,id:"f-stacks",title:"Stacks",tags:["stacks","backspace-string-compare","basic-calculator","evaluate-reverse-polish-notation","implement-queue-using-stacks","largest-rectangle-in-histogram","min-stack","trapping-rain-water","valid-parentheses"]},u="Stacks",o={unversionedId:"data-structures/f-stacks",id:"data-structures/f-stacks",title:"Stacks",description:"- Understanding stacks",source:"@site/docs/data-structures/f-stacks.md",sourceDirName:"data-structures",slug:"/data-structures/f-stacks",permalink:"/dsa/docs/data-structures/f-stacks",draft:!1,tags:[{label:"stacks",permalink:"/dsa/docs/tags/stacks"},{label:"backspace-string-compare",permalink:"/dsa/docs/tags/backspace-string-compare"},{label:"basic-calculator",permalink:"/dsa/docs/tags/basic-calculator"},{label:"evaluate-reverse-polish-notation",permalink:"/dsa/docs/tags/evaluate-reverse-polish-notation"},{label:"implement-queue-using-stacks",permalink:"/dsa/docs/tags/implement-queue-using-stacks"},{label:"largest-rectangle-in-histogram",permalink:"/dsa/docs/tags/largest-rectangle-in-histogram"},{label:"min-stack",permalink:"/dsa/docs/tags/min-stack"},{label:"trapping-rain-water",permalink:"/dsa/docs/tags/trapping-rain-water"},{label:"valid-parentheses",permalink:"/dsa/docs/tags/valid-parentheses"}],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,id:"f-stacks",title:"Stacks",tags:["stacks","backspace-string-compare","basic-calculator","evaluate-reverse-polish-notation","implement-queue-using-stacks","largest-rectangle-in-histogram","min-stack","trapping-rain-water","valid-parentheses"]},sidebar:"docs",previous:{title:"Hash Set",permalink:"/dsa/docs/data-structures/e-hash-set"},next:{title:"Queues",permalink:"/dsa/docs/data-structures/g-queues"}},c={},p=[{value:"Problems related to stacks",id:"problems-related-to-stacks",level:2},{value:"\u2197 See LeetCode Problem #844",id:"-see-leetcode-problem-844",level:3},{value:"\u2197 See LeetCode Problem #224",id:"-see-leetcode-problem-224",level:3},{value:"\u2197 See LeetCode Problem #150",id:"-see-leetcode-problem-150",level:3},{value:"\u2197 See LeetCode Problem #232",id:"-see-leetcode-problem-232",level:3},{value:"\u2197 See LeetCode Problem #84",id:"-see-leetcode-problem-84",level:3},{value:"\u2197 See LeetCode Problem #155",id:"-see-leetcode-problem-155",level:3},{value:"\u2197 See LeetCode Problem #42",id:"-see-leetcode-problem-42",level:3},{value:"\u2197 See LeetCode Problem #20",id:"-see-leetcode-problem-20",level:3}],m={toc:p};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"stacks"},"Stacks"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Understanding stacks "),(0,r.kt)("li",{parentName:"ul"},"Solved problems are presented in alphabetical order")),(0,r.kt)("h2",{id:"problems-related-to-stacks"},"Problems related to stacks"),(0,r.kt)("details",null,(0,r.kt)("summary",null," Backspace String Compare (Expand/Collapse) "),(0,r.kt)("h3",{id:"-see-leetcode-problem-844"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/backspace-string-compare/"},"\u2197 See LeetCode Problem #844")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},'import java.util.Deque;\nimport java.util.ArrayDeque;\n\npublic class Solution {\n    static boolean backspaceCompare(String s, String t) {\n        return build(s).equals(build(t));\n    }\n\n    static String build(String S) {\n\n        //  Create a stack using ArrayDeque\n        //  Code to interface (use Deque interface)\n        //      and ArrayDeque class\n        Deque<Character> resultStack = new ArrayDeque<>();\n\n        for (char c : S.toCharArray()) {\n           if (c != \'#\')\n               resultStack.push(c);\n           else if (!resultStack.isEmpty())\n               resultStack.pop();\n        }\n\n        return String.valueOf(resultStack);\n    }\n\n    public static void main(String[] args) {\n        // Example 1:\n        String s1 = "ab#c";\n        String t1 = "ad#c";\n        //  O/P: true\n\n        // Example 2:\n        String s2 = "ab##";\n        String t2 = "c#d#";\n        //  O/P: true\n\n        // Example 3:\n        String s3 = "a#c";\n        String t3 = "b";\n        //  O/P: false\n\n        System.out.println(backspaceCompare(s1,t1));\n        System.out.println(backspaceCompare(s2,t2));\n        System.out.println(backspaceCompare(s3,t3));\n    }\n}\n'))))),(0,r.kt)("details",null,(0,r.kt)("summary",null," Basic Calculator (Expand/Collapse) "),(0,r.kt)("h3",{id:"-see-leetcode-problem-224"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/basic-calculator/"},"\u2197 See LeetCode Problem #224")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"import java.util.Deque;\nimport java.util.ArrayDeque;\n\npublic class Solution {\n    public static int calculate(String s) {\n        //  Initialize the current operand\n        int currentOperand = 0;\n\n        //  Initialize the current sign:\n        //      1 for positive and -1 for negative\n        int currentSign = 1;\n\n        //  Initialize the result\n        //      to updated as required\n        //      before returning it at the end\n        int result = 0;\n\n        //  Declare a stack\n        //      to store result and sign every time\n        //      an open parenthesis is encountered\n        //  Push result before pushing sign\n        //      (done in separate statements)\n        Deque<Integer> myStack = new ArrayDeque<>();\n\n        //  Iterate over the entire length of the given string\n        for (int i = 0; i < s.length(); i++) {\n            //  Define a variable c to contain\n            //      the current character\n            char c = s.charAt(i);\n\n            if (Character.isDigit(c)) {\n                //  Update the current operand\n                //  Always subtract character '0' since\n                //      ASCII value of '0' is 48 and\n                //      digit characters following '0'\n                //      has correspoinding integer values added to 48\n                currentOperand = currentOperand * 10 + (int) (c - '0');\n            } else if (c == '+') {\n\n                // Update the result by evaluating the\n                //  current expression at the left\n                result += currentSign * currentOperand;\n\n                //  Reset the current sign to 1\n                currentSign = 1;\n\n                //  Reset the current operand to 0\n                currentOperand = 0;\n\n            } else if (c == '-') {\n                result += currentSign * currentOperand;\n\n                //  Update the current sign to -1\n                currentSign = -1;\n\n                //  Reset the current operand to 0\n                currentOperand = 0;\n\n            } else if (c == '(') {\n\n                //  Needs to access currentSign first\n                //      to deal with the final output\n                //      following the evaluation of\n                //      the expression inside the parentheses\n                //  So, push result first to stack\n                //      then, push the current sign to the same stack\n                myStack.push(result);\n                myStack.push(currentSign);\n\n                 //  Reset the current sign to 1\n                currentSign = 1;\n                //  Reset the current result to 0\n                result = 0;\n            } else if (c == ')') {\n\n                result +=  currentSign * currentOperand;\n\n                //  Pop the sign from the top of the stack\n                //      saved when its corresponding '('\n                //      was encountered\n                //  And, multiply the popped sign with the current result\n                result *= myStack.pop();\n\n                //  Pop the saved result from the top of the stack\n                //  And, add the popped result with the current result\n                result += myStack.pop();\n\n                //  Reset the current operand to 0\n                currentOperand = 0;\n            }\n\n        }\n\n        return result + (currentSign * currentOperand);\n    }\n\n    public static void main(String[] args) {\n        // Example 1:\n        String s1 = \"1 + 1\";\n        //  O/P: 2\n\n        // Example 2:\n        String s2 = \" 2-1 + 2 \";\n        //  O/P: 3\n\n        // Example 3:\n        String s3 = \"(1+(4+5+2)-3)+(6+8)\";\n        //  O/P: 23\n\n        System.out.println(calculate(s1));\n        System.out.println(calculate(s2));\n        System.out.println(calculate(s3));\n\n    }\n}\n"))))),(0,r.kt)("details",null,(0,r.kt)("summary",null," Evaluate Reverse Polish Notation (Expand/Collapse) "),(0,r.kt)("h3",{id:"-see-leetcode-problem-150"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/evaluate-reverse-polish-notation/"},"\u2197 See LeetCode Problem #150")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},'import java.util.Deque;\nimport java.util.ArrayDeque;\n\npublic class Solution {\n    public static int evalRPN(String[] tokens) {\n\n        Deque<Integer> myStack = new ArrayDeque<>();\n\n        for (String token : tokens) {\n\n            if (!"[+-*/]".contains(token)) {\n                myStack.push(Integer.valueOf(token));\n                continue;\n            }\n\n            //  2nd number is popped first\n            //      because stack\n            int numberTwo = myStack.pop();\n            int numberOne = myStack.pop();\n\n            int output = 0;\n\n            switch (token) {\n                case "+":\n                    output = numberOne + numberTwo;\n                    break;\n\n                case "-":\n                    output = numberOne - numberTwo;\n                    break;\n\n                case "*":\n                    output = numberOne * numberTwo;\n                    break;\n\n                case "/":\n                    output = numberOne / numberTwo;\n                    break;\n            }\n\n            myStack.push(output);\n        }\n\n        return myStack.pop();\n\n    }\n\n    public static void main (String[] args) {\n\n        // Example 1:\n        String[] tokens1 = {"2","1","+","3","*"};\n        //  O/P: 9\n\n        // Example 2:\n        String[] tokens2 = {"4","13","5","/","+"};\n        //  O/P: 6\n\n        // Example 3:\n        String[] tokens3 = {"10","6","9","3","+","-11","*","/","*","17","+","5","+"};\n        //  O/P: 22\n\n        System.out.println(evalRPN(tokens1));\n        System.out.println(evalRPN(tokens2));\n        System.out.println(evalRPN(tokens3));\n\n    }\n}\n'))))),(0,r.kt)("details",null,(0,r.kt)("summary",null," Implement Queue Using Stacks (Expand/Collapse) "),(0,r.kt)("h3",{id:"-see-leetcode-problem-232"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/implement-queue-using-stacks/"},"\u2197 See LeetCode Problem #232")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},'//import java.util.ArrayDeque;\n//import java.util.Deque;\nimport java.util.Stack;\n\nclass MyQueue {\n\n//    private Deque<Integer> stack1 = new ArrayDeque<>();\n//    private Deque<Integer> stack2 = new ArrayDeque<>();\n    private Stack<Integer> stack1 = new Stack<>();\n    private Stack<Integer> stack2 = new Stack<>();\n    private int topElement;\n    public MyQueue() {\n\n    }\n\n    public void push(int x) {\n        if (stack1.isEmpty()) {\n            topElement = x;\n        }\n        stack1.push(x);\n    }\n\n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n\n    public int peek() {\n        if(!stack2.isEmpty()) {\n            return stack2.peek();\n        }\n        return topElement;\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n\npublic class Solution {\n    public static void main(String[] args) {\n\n        // Example 1:\n        //Input\n        //["MyQueue", "push", "push", "peek", "pop", "empty"]\n        //[[], [1], [2], [], [], []]\n        //  O/P: //[null, null, null, 1, 1, false]\n\n        MyQueue myQueue = new MyQueue();\n        myQueue.push(1);\n        myQueue.push(2);\n        System.out.println(myQueue.peek());\n        System.out.println(myQueue.pop());\n        System.out.println(myQueue.empty());\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n'))))),(0,r.kt)("details",null,(0,r.kt)("summary",null," Largest Rectangle in Histogram (Expand/Collapse) "),(0,r.kt)("h3",{id:"-see-leetcode-problem-84"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/largest-rectangle-in-histogram/"},"\u2197 See LeetCode Problem #84")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"import java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class Solution {\n    public static int largestRectangleArea(int[] heights) {\n        //  Initialize largest area with 0\n        int largestArea = 0;\n\n        //  Creat a stack\n        Deque<Integer> myStack = new ArrayDeque<>();\n        //  Push -1 to the stack to help with out of bounds\n        //      calculations\n        myStack.push(-1);\n\n        //  Iterate over all elements in the given heights array\n        for (int i = 0; i < heights.length; i++) {\n            //  Calculate and update largestArea if\n            //      element on top of the stack\n            //      is bigger than the current element\n            while (myStack.peek() != -1 &&\n                   heights[i] <= heights[myStack.peek()]) {\n                //  current height/element\n                int currentMaxHeight = heights[myStack.pop()];\n                //  myStack.peek()\u2014after myStack.pop() in line above\u2014\n                //      is left boundary\n                //      and i is right boundary\n                //      subtract -1 because 0-indexed\n                int currentWidth = i - myStack.peek() - 1;\n\n                largestArea = Math.max(largestArea,\n                        currentMaxHeight * currentWidth);\n            }\n\n            myStack.push(i);\n        }\n\n        //  For the last element in the given heights array\n        while (myStack.peek() != -1) {\n            //  last height/element\n            int currentMaxHeight = heights[myStack.pop()];\n            //  myStack.peek()\u2014after myStack.pop() in line above\u2014\n            //      is left boundary\n            //      and heights.length is right boundary\n            //      subtract -1 because 0-indexed\n            int currentWidth = heights.length - myStack.peek() - 1;\n\n            largestArea = Math.max(largestArea,\n                    currentMaxHeight * currentWidth);\n\n        }\n\n        return largestArea;\n    }\n\n    public static void main(String[] args) {\n        // Example 1:\n        int[] heights1 = {2,1,5,6,2,3};\n        //  O/P: 10\n\n        // Example 2:\n        int[] heights2 = {2,4};\n        //  O/P: 4\n\n        System.out.println(largestRectangleArea(heights1));\n        System.out.println(largestRectangleArea(heights2));\n    }\n}\n"))))),(0,r.kt)("details",null,(0,r.kt)("summary",null," Min Stack (Expand/Collapse) "),(0,r.kt)("h3",{id:"-see-leetcode-problem-155"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/min-stack/"},"\u2197 See LeetCode Problem #155")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},'import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Arrays;\n\npublic class Solution {\n    private static Deque<Integer> myStack = new ArrayDeque<>();\n    private static Deque<int[]> minimumStack = new ArrayDeque<>();\n\n    public Solution() {\n\n    }\n\n    public static void push(int val) {\n        myStack.push(val);\n\n        if (minimumStack.isEmpty() ||\n            val < minimumStack.peek()[0]) {\n            minimumStack.push(new int[] {val, 1});\n        } else if (val == minimumStack.peek()[0]) {\n            minimumStack.peek()[1]++;\n        }\n    }\n\n    public static void pop() {\n\n        if (myStack.peek().equals(minimumStack.peek()[0])) {\n            minimumStack.peek()[1]--;\n        }\n\n        if (minimumStack.peek()[1] == 0) {\n            minimumStack.pop();\n        }\n\n        myStack.pop();\n    }\n\n    public static int top() {\n        return myStack.peek();\n    }\n\n    public static int getMin() {\n        return minimumStack.peek()[0];\n    }\n\n    public static void main(String[] args) {\n        // Example 1:\n        //Input\n        //["MinStack","push","push","push","getMin","pop","top","getMin"]\n        //[[],[-2],[0],[-3],[],[],[],[]]\n        //Output\n        //[null,null,null,null,-3,null,0,-2]\n\n    //Explanation\n    //MinStack minStack = new MinStack();\n    //minStack.push(-2);\n    //minStack.push(0);\n    //minStack.push(-3);\n    //minStack.getMin(); // return -3\n    //minStack.pop();\n    //minStack.top();    // return 0\n    //minStack.getMin(); // return -2\n\n       Solution minStack = new Solution();\n       System.out.println(Arrays.toString(minStack.myStack.toArray()));\n\n       minStack.push(-2);\n       System.out.println(Arrays.toString(minStack.myStack.toArray()));\n\n       minStack.push(0);\n       System.out.println(Arrays.toString(minStack.myStack.toArray()));\n\n       minStack.push(-3);\n       System.out.println(Arrays.toString(minStack.myStack.toArray()));\n\n       minStack.getMin();\n       System.out.println(minStack.getMin());\n\n       minStack.pop();\n\n       minStack.top();\n       System.out.println(minStack.top());\n\n       minStack.getMin();\n       System.out.println(minStack.getMin());\n\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n'))))),(0,r.kt)("details",null,(0,r.kt)("summary",null," Trapping Rain Water (Expand/Collapse) "),(0,r.kt)("h3",{id:"-see-leetcode-problem-42"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/trapping-rain-water/"},"\u2197 See LeetCode Problem #42")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"public class Solution {\n    public static int trap(int[] height) {\n        int leftIndex = 0;\n        int leftMax = 0;\n        int rightIndex = height.length - 1;\n        int rightMax = 0;\n        int result = 0;\n\n        //  Continue while left index stays smaller than\n        //      the right index as the given height array is being traversed\n        while (leftIndex < rightIndex) {\n            //  Check if the height at the left index is greater than\n            //      the height at right index\n            if (height[leftIndex] < height[rightIndex]) {\n\n                //  For true if condition, check if height at the left index\n                //      is greater than or equal to leftMax height\n                if (height[leftIndex] >= leftMax) {\n                    // For true if condition, update leftMax\n                    leftMax = height[leftIndex];\n                } else {\n                    result += leftMax - height[leftIndex];\n                }\n                //  Increase left index by 1\n                leftIndex++;\n\n            //  For false if condition, check if height at the right index\n            //      is greater than or equal to rightMax height\n            } else {\n                 if (height[rightIndex] >= rightMax) {\n                    // For true if condition, update rightMax\n                    rightMax = height[rightIndex];\n                 } else {\n                    result += rightMax - height[rightIndex];\n                 }\n                 //  Decrease right index by 1\n                 rightIndex--;\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Example 1:\n        int[] height1 = {0,1,0,2,1,0,1,3,2,1,2,1};\n        //Output: 6\n\n        // Example 2:\n        int[] height2 = {4,2,0,3,2,5};\n        //  O/P: 9\n\n        System.out.println(trap(height1));\n        System.out.println(trap(height2));\n    }\n}\n"))))),(0,r.kt)("details",null,(0,r.kt)("summary",null," Valid Parentheses (Expand/Collapse) "),(0,r.kt)("h3",{id:"-see-leetcode-problem-20"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/valid-parentheses/"},"\u2197 See LeetCode Problem #20")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"import java.util.HashMap;\nimport java.util.Stack;\n\nclass Solution {\n\n     static boolean isValid(String s) {\n\n         HashMap<Character, Character> mappings = new HashMap<>();\n             mappings.put(')', '(');\n             mappings.put(']', '[');\n             mappings.put('}', '{');\n\n        Stack<Character> myStack = new Stack<>();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (mappings.containsKey(c)) {\n                char topElement = myStack.isEmpty() ? '#' : myStack.pop();\n\n                if (topElement != mappings.get(c)) {\n                    return false;\n                }\n\n            } else {\n                myStack.push(c);\n            }\n        }\n        return myStack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n\n        //Output: true\n        String s1 = \"()\";\n\n        //Output: true\n        String s2 = \"()[]{}\";\n\n        //Output: false\n        String s3 = \"(]\";\n\n        isValid(s1);\n        System.out.println(isValid(s1));\n\n    }\n}\n"))))))}d.isMDXComponent=!0}}]);