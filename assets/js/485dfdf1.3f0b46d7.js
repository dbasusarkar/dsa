"use strict";(self.webpackChunkdsa=self.webpackChunkdsa||[]).push([[9598],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),m=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=m(e.components);return a.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=m(t),d=r,b=p["".concat(s,".").concat(d)]||p[d]||c[d]||o;return t?a.createElement(b,i(i({ref:n},u),{},{components:t})):a.createElement(b,i({ref:n},u))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=p;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var m=2;m<o;m++)i[m]=t[m];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},5162:(e,n,t)=>{t.d(n,{Z:()=>i});var a=t(7294),r=t(6010);const o="tabItem_Ymn6";function i(e){let{children:n,hidden:t,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(o,i),hidden:t},n)}},5488:(e,n,t)=>{t.d(n,{Z:()=>d});var a=t(7462),r=t(7294),o=t(6010),i=t(2389),l=t(7392),s=t(7094),m=t(2466);const u="tabList__CuJ",c="tabItem_LNqP";function p(e){var n;const{lazy:t,block:i,defaultValue:p,values:d,groupId:b,className:g}=e,h=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),f=d??h.map((e=>{let{props:{value:n,label:t,attributes:a}}=e;return{value:n,label:t,attributes:a}})),v=(0,l.l)(f,((e,n)=>e.value===n.value));if(v.length>0)throw new Error(`Docusaurus error: Duplicate values "${v.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const y=null===p?p:p??(null==(n=h.find((e=>e.props.default)))?void 0:n.props.value)??h[0].props.value;if(null!==y&&!f.some((e=>e.value===y)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${y}" but none of its children has the corresponding value. Available values are: ${f.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:S,setTabGroupChoices:k}=(0,s.U)(),[w,x]=(0,r.useState)(y),P=[],{blockElementScrollPositionUntilNextRender:C}=(0,m.o5)();if(null!=b){const e=S[b];null!=e&&e!==w&&f.some((n=>n.value===e))&&x(e)}const N=e=>{const n=e.currentTarget,t=P.indexOf(n),a=f[t].value;a!==w&&(C(n),x(a),null!=b&&k(b,String(a)))},O=e=>{var n;let t=null;switch(e.key){case"ArrowRight":{const n=P.indexOf(e.currentTarget)+1;t=P[n]??P[0];break}case"ArrowLeft":{const n=P.indexOf(e.currentTarget)-1;t=P[n]??P[P.length-1];break}}null==(n=t)||n.focus()};return r.createElement("div",{className:(0,o.Z)("tabs-container",u)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":i},g)},f.map((e=>{let{value:n,label:t,attributes:i}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:w===n?0:-1,"aria-selected":w===n,key:n,ref:e=>P.push(e),onKeyDown:O,onFocus:N,onClick:N},i,{className:(0,o.Z)("tabs__item",c,null==i?void 0:i.className,{"tabs__item--active":w===n})}),t??n)}))),t?(0,r.cloneElement)(h.filter((e=>e.props.value===w))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},h.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==w})))))}function d(e){const n=(0,i.Z)();return r.createElement(p,(0,a.Z)({key:String(n)},e))}},140:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>m,toc:()=>c});var a=t(7462),r=(t(7294),t(3905)),o=t(5488),i=t(5162);const l={sidebar_position:9,id:"i-dp",title:"Dynamic Programming",tags:["dp","climbing-stairs","coin-change","longest-common-subsequence","partition-equal-subset-sum","unique-paths"]},s="Dynamic Programming",m={unversionedId:"patterns/i-dp",id:"patterns/i-dp",title:"Dynamic Programming",description:"- Understanding dynamic programming",source:"@site/docs/patterns/i-dp.md",sourceDirName:"patterns",slug:"/patterns/i-dp",permalink:"/dsa/docs/patterns/i-dp",draft:!1,tags:[{label:"dp",permalink:"/dsa/docs/tags/dp"},{label:"climbing-stairs",permalink:"/dsa/docs/tags/climbing-stairs"},{label:"coin-change",permalink:"/dsa/docs/tags/coin-change"},{label:"longest-common-subsequence",permalink:"/dsa/docs/tags/longest-common-subsequence"},{label:"partition-equal-subset-sum",permalink:"/dsa/docs/tags/partition-equal-subset-sum"},{label:"unique-paths",permalink:"/dsa/docs/tags/unique-paths"}],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9,id:"i-dp",title:"Dynamic Programming",tags:["dp","climbing-stairs","coin-change","longest-common-subsequence","partition-equal-subset-sum","unique-paths"]},sidebar:"docs",previous:{title:"Bit Manipulation",permalink:"/dsa/docs/patterns/h-bit-manipulation"},next:{title:"Matrices",permalink:"/dsa/docs/patterns/j-matrices"}},u={},c=[{value:"Problems related to dynamic programming",id:"problems-related-to-dynamic-programming",level:2},{value:"\u2197 See LeetCode Problem #70",id:"-see-leetcode-problem-70",level:3},{value:"\u2197 See LeetCode Problem #322",id:"-see-leetcode-problem-322",level:3},{value:"\u2197 See LeetCode Problem #1143",id:"-see-leetcode-problem-1143",level:3},{value:"\u2197 Maximum Subarray",id:"-maximum-subarray",level:3},{value:"\u2197 See LeetCode Problem #416",id:"-see-leetcode-problem-416",level:3},{value:"\u2197 See LeetCode Problem #62",id:"-see-leetcode-problem-62",level:3}],p={toc:c};function d(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"dynamic-programming"},"Dynamic Programming"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Understanding dynamic programming "),(0,r.kt)("li",{parentName:"ul"},"Solved problems are presented in alphabetical order")),(0,r.kt)("h2",{id:"problems-related-to-dynamic-programming"},"Problems related to dynamic programming"),(0,r.kt)("details",null,(0,r.kt)("summary",null," Climbing Stairs (Expand/Collapse) "),(0,r.kt)("h3",{id:"-see-leetcode-problem-70"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/climbing-stairs/"},"\u2197 See LeetCode Problem #70")),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"public class Solution {\n   static int climbingStairs (int n) {\n\n        if (n == 0 || n == 1) return 1;\n\n        int[] numWays = new int[n + 1];\n\n        numWays[0] = 1;\n        numWays[1] = 1;\n\n        for (int i = 2; i <= n; i++) {\n            numWays[i] = numWays[i -1] + numWays[i - 2];\n        }\n\n        return numWays[n];\n    }\n\n    public static void main(String[] args) {\n        int n1 = 2;\n        int n2 = 3;\n        int n3 = 8;\n\n//        climbingStairs(n1);\n//        climbingStairs(n2);\n//        climbingStairs(n3);\n\n        System.out.println(climbingStairs(n1));\n        System.out.println(climbingStairs(n2));\n        System.out.println(climbingStairs(n3));\n    }\n\n}\n"))))),(0,r.kt)("details",null,(0,r.kt)("summary",null," Coin Change (Expand/Collapse) "),(0,r.kt)("h3",{id:"-see-leetcode-problem-322"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/coin-change/"},"\u2197 See LeetCode Problem #322")),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"import java.util.Arrays;\n\npublic class Solution {\n    static int coinChange(int[] coins, int amount) {\n\n        //  Approach: Dynamic Programming - Bottom Up\n        //  Iterative Solution\n\n        //  Because going from 0 to amount\n        int max = amount + 1;\n        int[] dp = new int[max];\n        Arrays.fill(dp, max);\n        dp[0] = 0;\n\n        for (int i = 1; i <= amount; i++) {\n            for (int j = 0; j < coins.length; j++) {\n                if (coins[j] <= i) {\n                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n\n    public static void main(String[] args) {\n        // Example 1:\n        int[] coins1 = {1, 2, 5};\n        int amount1 = 11;\n        //  O/P: 3\n\n        // Example 2:\n        int[] coins2 = {2};\n        int amount2 = 3;\n        //  O/P: -1\n\n        // Example 3:\n        int[] coins3 = {1};\n        int amount3 = 0;\n        //  O/P: 0\n\n        System.out.println(coinChange(coins1, amount1));\n        System.out.println(coinChange(coins2, amount2));\n        System.out.println(coinChange(coins3, amount3));\n    }\n}\n"))))),(0,r.kt)("details",null,(0,r.kt)("summary",null," Longest Common Subsequence (Expand/Collapse) "),(0,r.kt)("h3",{id:"-see-leetcode-problem-1143"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/longest-common-subsequence/"},"\u2197 See LeetCode Problem #1143")),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},'public class Solution {\n    static int longestCommonSubsequence(String text1, String text2) {\n\n        //   Make a grid of 0\'s with text2.length() + 1 columns\n        //      and text1.length() + 1 rows\n        int[][] dpGrid = new int[text1.length() + 1][text2.length() + 1];\n\n        //  Iterate up each column, starting from the last one\n        for (int col = text2.length() - 1; col >=0; col--) {\n            for (int row = text1.length() - 1; row >=0; row--) {\n                //  If the corresponding characters for this cell are the same\n                if (text1.charAt(row) == text2.charAt(col)) {\n                    dpGrid[row][col] = 1 + dpGrid[row + 1][col + 1];\n                    //  Otherwise they must be different\n                } else {\n                    dpGrid[row][col] = Math.max(dpGrid[row + 1][col],\n                            dpGrid[row][col + 1]);\n                }\n            }\n        }\n        //  The original problem\'s answer is in dpGrid[0][0]. Return it.\n        return dpGrid[0][0];\n    }\n\n    public static void main(String[] args) {\n        // Example 1:\n        String textA1 = "abcde";\n        String textA2 = "ace";\n        //  O/P: 3\n\n        // Example 2:\n        String textB1 = "abc";\n        String textB2 = "abc";\n        //  O/P: 3\n\n        // Example 3:\n        String textC1 = "abc";\n        String textC2 = "def";\n        //  O/P: 0\n\n        System.out.println(longestCommonSubsequence(textA1, textA2));\n        System.out.println(longestCommonSubsequence(textB1, textB2));\n        System.out.println(longestCommonSubsequence(textC1, textC2));\n    }\n}\n'))))),(0,r.kt)("details",null,(0,r.kt)("summary",null," Maximum Subarray (Expand/Collapse) "),(0,r.kt)("h3",{id:"-maximum-subarray"},(0,r.kt)("a",{parentName:"h3",href:"/dsa/docs/algorithms/e-greedy"},"\u2197 Maximum Subarray"))),(0,r.kt)("details",null,(0,r.kt)("summary",null," Partition Equal Subset Sum (Expand/Collapse) "),(0,r.kt)("h3",{id:"-see-leetcode-problem-416"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/partition-equal-subset-sum/"},"\u2197 See LeetCode Problem #416")),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"public class Solution {\n    public static boolean canPartition(int[] nums) {\n        //  Check for empty given array of integers (nums)\n        //  If nums is empty return false\n        if (nums.length == 0) {\n            return false;\n        }\n\n        //  Declare numsLength to store the length of nums\n        //      to make iteration for efficient\n        int numsLength = nums.length;\n\n        //  Declare and initialize an integer variable called totalSum\n        int totalSum = 0;\n\n        //  Iterate over the given array to find\n        //      the total sum of its elements\n        //      using a for loop\n        for (int i = 0; i < numsLength; i++) {\n            totalSum += nums[i];\n        }\n\n        //  Since two partitions of equal sum,\n        //      totalSum cannot be odd.\n        //  If totalSum is odd return false\n        if (totalSum % 2 != 0) {\n            return false;\n        }\n\n        //  Since two partitions of equal sum,\n        //      the sum of all elements in each partition\n        //      is equal to totalSum / 2.\n        //  So, declare equalPartitionSum\n        int equalPartitionSum = totalSum / 2;\n\n        //  For memoization, dclare an array to contain boolean values\n        boolean[] memo = new boolean[equalPartitionSum + 1];\n\n        //  Set first element of memo to true\n        //      since it's an array of sum and at\n        //      sum = 0 when following bottom-up approach\n        //      it's true\n        memo[0] = true;\n\n        //  Iterate over all elements in nums\n        for (int num : nums) {\n            for (int sum = equalPartitionSum; sum >= num; sum--) {\n                //  Perform Bitwise OR operation (|=);\n                //      assign memo[sum] the result of\n                //      the Bitwise OR operation between\n                //      memo[sum] and memo[sum - num]\n                //  e.g., if memo[sum] = true or 1 and\n                //         memo[sum - num] = false or 0\n                //  memo[sum] |= memo[sum - num] gives\n                //  memo[sum] = true or 1b;\n                //  memo[sum]: dp case excluding current index\n                //  memo[sum - sum]: dp case including current index\n                //  So, memo[sum] || memo[sum - num] gives the result\n                memo[sum] |= memo[sum - num];\n            }\n        }\n\n        return memo[equalPartitionSum];\n    }\n\n    public static void main(String[] args) {\n        // Example 1:\n        int[] nums = {1,5,11,5};\n        System.out.println(canPartition(nums));\n        //  O/P: true\n\n        // Example 2:\n        nums = new int[] {1,2,3,5};\n        System.out.println(canPartition(nums));\n        //  O/P: false\n    }\n\n}\n"))))),(0,r.kt)("details",null,(0,r.kt)("summary",null," Unique Paths (Expand/Collapse) "),(0,r.kt)("h3",{id:"-see-leetcode-problem-62"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/unique-paths/"},"\u2197 See LeetCode Problem #62")),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"import java.util.Arrays;\n\npublic class Solution {\n    public static int uniquePaths(int m, int n) {\n//        //  Approach 1: Brute-force recursive method\n//        if (m == 1 || n == 1) {\n//            return 1;\n//        }\n//        return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);\n\n        //  Approach 2: Dynamic Programming (optimized recursion)\n\n        //  Declare 2D dp array/memo to store previous results\n        //      so that these can be used later if\n        //      the same cell (m, n) is encountered again\n        //  m = row; n = column\n        int[][] dp = new int[m][n];\n\n        //  Set all cells to have a value of 1\n        for (int[] array : dp) {\n            Arrays.fill(array, 1);\n        }\n\n        //  Iterate over all cells following a top-down\n        //      approach\n        //  NOTE: both row and column starts at index 1\n        //  dp[0][1] or dp[0][column] or dp[0][1] or dp[row][0]\n        //      is 1 since all cells set to 1\n        //      in the for-each loop above\n        //  That is, number of paths = 1 for the first row/column\n        for (int row = 1; row < m; row++) {\n             for (int column = 1; column < n; column++) {\n                 // dp [currentRow][currentColumn] is obtained adding\n                 //     dp [previousRow][currentColumn] and\n                 //     dp [currentRow][previousColumn]\n                 dp [row][column] = dp [row - 1][column] + dp [row][column - 1];\n             }\n        }\n\n        return dp[m - 1][n - 1];\n    }\n\n    public static void main(String[] args) {\n        // Example 1:\n        int m = 3;\n        int n = 7;\n        System.out.println(uniquePaths(m, n));\n        //  O/P: 28\n\n    // Example 2:\n        m = 3;\n        n = 2;\n        System.out.println(uniquePaths(m, n));\n        //  O/P: 3\n\n    }\n}\n"))))))}d.isMDXComponent=!0}}]);