"use strict";(self.webpackChunkdsa=self.webpackChunkdsa||[]).push([[8956],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>h});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),d=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=d(e.components);return r.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=d(t),h=a,p=m["".concat(l,".").concat(h)]||m[h]||u[h]||i;return t?r.createElement(p,o(o({ref:n},c),{},{components:t})):r.createElement(p,o({ref:n},c))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var d=2;d<i;d++)o[d]=t[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5162:(e,n,t)=>{t.d(n,{Z:()=>o});var r=t(7294),a=t(6010);const i="tabItem_Ymn6";function o(e){let{children:n,hidden:t,className:o}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(i,o),hidden:t},n)}},5488:(e,n,t)=>{t.d(n,{Z:()=>h});var r=t(7462),a=t(7294),i=t(6010),o=t(2389),s=t(7392),l=t(7094),d=t(2466);const c="tabList__CuJ",u="tabItem_LNqP";function m(e){var n;const{lazy:t,block:o,defaultValue:m,values:h,groupId:p,className:g}=e,f=a.Children.map(e.children,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),b=h??f.map((e=>{let{props:{value:n,label:t,attributes:r}}=e;return{value:n,label:t,attributes:r}})),v=(0,s.l)(b,((e,n)=>e.value===n.value));if(v.length>0)throw new Error(`Docusaurus error: Duplicate values "${v.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const w=null===m?m:m??(null==(n=f.find((e=>e.props.default)))?void 0:n.props.value)??f[0].props.value;if(null!==w&&!b.some((e=>e.value===w)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${w}" but none of its children has the corresponding value. Available values are: ${b.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:y,setTabGroupChoices:N}=(0,l.U)(),[S,k]=(0,a.useState)(w),L=[],{blockElementScrollPositionUntilNextRender:x}=(0,d.o5)();if(null!=p){const e=y[p];null!=e&&e!==S&&b.some((n=>n.value===e))&&k(e)}const j=e=>{const n=e.currentTarget,t=L.indexOf(n),r=b[t].value;r!==S&&(x(n),k(r),null!=p&&N(p,String(r)))},C=e=>{var n;let t=null;switch(e.key){case"ArrowRight":{const n=L.indexOf(e.currentTarget)+1;t=L[n]??L[0];break}case"ArrowLeft":{const n=L.indexOf(e.currentTarget)-1;t=L[n]??L[L.length-1];break}}null==(n=t)||n.focus()};return a.createElement("div",{className:(0,i.Z)("tabs-container",c)},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":o},g)},b.map((e=>{let{value:n,label:t,attributes:o}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:S===n?0:-1,"aria-selected":S===n,key:n,ref:e=>L.push(e),onKeyDown:C,onFocus:j,onClick:j},o,{className:(0,i.Z)("tabs__item",u,null==o?void 0:o.className,{"tabs__item--active":S===n})}),t??n)}))),t?(0,a.cloneElement)(f.filter((e=>e.props.value===S))[0],{className:"margin-top--md"}):a.createElement("div",{className:"margin-top--md"},f.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==S})))))}function h(e){const n=(0,o.Z)();return a.createElement(m,(0,r.Z)({key:String(n)},e))}},417:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>u});var r=t(7462),a=(t(7294),t(3905)),i=t(5488),o=t(5162);const s={sidebar_position:10,id:"k-graphs",title:"Graphs",tags:["graphs","disjoint-set","union-find","accounts-merge","alien-dictionary","clone-graph","course-schedule","flood-fill","minimum-height-trees","number-of-islands","rotting-oranges","word-ladder","word-search","01-matrix"]},l="Graphs",d={unversionedId:"data-structures/k-graphs",id:"data-structures/k-graphs",title:"Graphs",description:"- Understanding graphs",source:"@site/docs/data-structures/k-graphs.md",sourceDirName:"data-structures",slug:"/data-structures/k-graphs",permalink:"/dsa/docs/data-structures/k-graphs",draft:!1,tags:[{label:"graphs",permalink:"/dsa/docs/tags/graphs"},{label:"disjoint-set",permalink:"/dsa/docs/tags/disjoint-set"},{label:"union-find",permalink:"/dsa/docs/tags/union-find"},{label:"accounts-merge",permalink:"/dsa/docs/tags/accounts-merge"},{label:"alien-dictionary",permalink:"/dsa/docs/tags/alien-dictionary"},{label:"clone-graph",permalink:"/dsa/docs/tags/clone-graph"},{label:"course-schedule",permalink:"/dsa/docs/tags/course-schedule"},{label:"flood-fill",permalink:"/dsa/docs/tags/flood-fill"},{label:"minimum-height-trees",permalink:"/dsa/docs/tags/minimum-height-trees"},{label:"number-of-islands",permalink:"/dsa/docs/tags/number-of-islands"},{label:"rotting-oranges",permalink:"/dsa/docs/tags/rotting-oranges"},{label:"word-ladder",permalink:"/dsa/docs/tags/word-ladder"},{label:"word-search",permalink:"/dsa/docs/tags/word-search"},{label:"01-matrix",permalink:"/dsa/docs/tags/01-matrix"}],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10,id:"k-graphs",title:"Graphs",tags:["graphs","disjoint-set","union-find","accounts-merge","alien-dictionary","clone-graph","course-schedule","flood-fill","minimum-height-trees","number-of-islands","rotting-oranges","word-ladder","word-search","01-matrix"]},sidebar:"docs",previous:{title:"Binary Trees",permalink:"/dsa/docs/data-structures/j-binary-trees"},next:{title:"Tries",permalink:"/dsa/docs/data-structures/l-tries"}},c={},u=[{value:"Problems related to graphs",id:"problems-related-to-graphs",level:2},{value:"\u2197 See LeetCode Problem #721",id:"-see-leetcode-problem-721",level:3},{value:"\ud83c\udff7 disjoint-set",id:"-disjoint-set",level:3},{value:"\ud83c\udff7 union-find",id:"-union-find",level:3},{value:"\u2197 See LeetCode Problem #269",id:"-see-leetcode-problem-269",level:3},{value:"\u2197 See LeetCode Problem #133",id:"-see-leetcode-problem-133",level:3},{value:"\u2197 See LeetCode Problem #207",id:"-see-leetcode-problem-207",level:3},{value:"\u2197 See LeetCode Problem #733",id:"-see-leetcode-problem-733",level:3},{value:"\u2197 See LeetCode Problem #310",id:"-see-leetcode-problem-310",level:3},{value:"\u2197 See LeetCode Problem #200",id:"-see-leetcode-problem-200",level:3},{value:"\u2197 See LeetCode Problem #994",id:"-see-leetcode-problem-994",level:3},{value:"\u2197 Word Ladder",id:"-word-ladder",level:3},{value:"\u2197 See LeetCode Problem #79",id:"-see-leetcode-problem-79",level:3},{value:"\u2197 See LeetCode Problem #542",id:"-see-leetcode-problem-542",level:3}],m={toc:u};function h(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"graphs"},"Graphs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Understanding graphs "),(0,a.kt)("li",{parentName:"ul"},"Solved problems are presented in alphabetical order")),(0,a.kt)("h2",{id:"problems-related-to-graphs"},"Problems related to graphs"),(0,a.kt)("details",null,(0,a.kt)("summary",null," Accounts Merge "),(0,a.kt)("h3",{id:"-see-leetcode-problem-721"},(0,a.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/accounts-merge/"},"\u2197 See LeetCode Problem #721")),(0,a.kt)("h3",{id:"-disjoint-set"},"\ud83c\udff7 disjoint-set"),(0,a.kt)("h3",{id:"-union-find"},"\ud83c\udff7 union-find"),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},'import java.util.Map;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.TreeSet;\n\npublic class Solution {\n    public static List<List<String>> accountsMerge(List<List<String>> accounts) {\n\n        //  Approach #1: Using Disjoint Set or Union-Find Data Structure\n        /* *** *** *** *** *** Approach #1 Starts *** *** *** *** */\n\n        //  Declare a HashMap to store the names as values\n        //      correspoding to the first email in each list as the key\n        Map<String, String> emailsToNames = new HashMap<>();\n\n        //  Declare a HashMap to set all emails (keys)\n        //      as their own parents/roots (values)\n        Map<String, String> emailsToParentEmails = new HashMap<>();\n\n        //  Declare a HashMap to store the combined list of all emails\n        //      using union between email lists (hence TreeSet as values)\n        Map<String, TreeSet<String>> emailToEmailUnions = new HashMap<>();\n\n        //  Iterate over the lists of accounts to update\n        //      the emailsToNames and emailsToParentEmails maps\n        for (List<String> a : accounts) {\n            //  Also, iterate over all emails in each account\n            //  Index starts from 1 to skip the name\n            for (int email = 1; email < a.size(); email++) {\n                //  Map all emails (keys) to the name (value)\n                emailsToNames.put(a.get(email), a.get(0));\n                //  Map each email as its own parent/root\n                emailsToParentEmails.put(a.get(email), a.get(email));\n            }\n        }\n\n        //  Iterate over the lists of accounts to agin update\n        //      emailsToParentEmails map\n        for (List<String> a : accounts) {\n            //  Find the parent of the first email in the current list\n            String parentEmail = find(a.get(1), emailsToParentEmails);\n            //  Also, iterate over all emails in each account\n            //  Index starts from 2 to skip the name\n            //      and the first email in the given list\n            for (int email = 2; email < a.size(); email++) {\n                //  Set current parentEmail as the value\n                //      (parent) of all remaining emails (keys)\n                emailsToParentEmails.put(\n                        //  Use the find method\n                        //      to find the parents of all remaining emails\n                        //      in the current list/account\n                        find(a.get(email), emailsToParentEmails),\n                        parentEmail);\n            }\n        }\n\n        //  Iterate over the lists of accounts to perform\n        //      unions between email lists using TreeSet\n        //      (TreeSet to list emails in sorted order)\n        for(List<String> a : accounts) {\n            //  Find the parent of the first email in the current list\n            String parentEmail = find(a.get(1), emailsToParentEmails);\n            //  Check if the emailToEmailUnions map already has the\n            //      parentEmail as a key, if not put it in the map\n            //      along with a new empty TreeSet as the value\n            if(!emailToEmailUnions.containsKey(parentEmail)) {\n                emailToEmailUnions.put(parentEmail, new TreeSet<>());\n            }\n            //  Iterate over all emails in the current list/account\n            for (int email = 1; email < a.size(); email++) {\n                //  Get access to the newly created or already existing TreeSet\n                //      passed on as a value corresponding to the parentEmail\n                //      key in the emailToEmailUnions map,\n                //      and add the current email to this TreeSet\n                //      to build the mergedAccounts list only with emails\n                emailToEmailUnions.get(parentEmail).add(a.get(email));\n            }\n        }\n\n        //  Declare a list of lists to store all the merged accounts\n        List<List<String>> mergedAccountsList = new ArrayList<>();\n\n        //  Iterate over all keys from the emailToEmailUnions map\n        for (String email: emailToEmailUnions.keySet()) {\n            //  Declare a new list and initialize with the TreeSet\n            //      obtained using emailToEmailUnions.get(email)\n            List<String> mergedAccounts = new ArrayList<>(emailToEmailUnions.get(email));\n\n            //  Add the name (from the emailsToNames map)\n            //      corresponding to the current email\n            //      as the first element of the merged accounts list\n            mergedAccounts.add(0, emailsToNames.get(email));\n            //  Add the current list of merged accounts\n            //      to the output list of lists\n            mergedAccountsList.add(mergedAccounts);\n        }\n        //  return the list of merged accounts\n        return mergedAccountsList;\n    }\n\n     //  Implement the find method to find\n     //     the parent email of a given email from a given list\n    private static String find(String email, Map<String, String> map) {\n        //  Using a ternary operation that checks the equality\n        //      between the given emailsToParentEmails map\n        //          and the given string\n        //      return the given string if conditon true\n        //      or make recursive calls to the same find method\n        //          if conditon false\n        return map.get(email) == email ? email : find(map.get(email), map);\n    }\n    /* *** *** *** *** *** Approach #1 Ends *** *** *** *** *** */\n\n    public static void main(String[] args) {\n\n        // Example 1:\n        List<List<String>> accounts = List.of (\n                List.of("John","johnsmith@mail.com","john_newyork@mail.com"),\n                List.of("John","johnsmith@mail.com","john00@mail.com"),\n                List.of("Mary","mary@mail.com"),\n                List.of("John","johnnybravo@mail.com")\n        );\n\n        System.out.println(accountsMerge(accounts));\n        //Output: [["John","john00@mail.com","john_newyork@mail.com","johnsmith@mail.\n        //com"],["Mary","mary@mail.com"],["John","johnnybravo@mail.com"]]\n\n        System.out.println("-------------------");\n        // Example 2:\n        accounts = List.of (\n                List.of("Gabe","Gabe0@m.co","Gabe3@m.co","Gabe1@m.co"),\n                List.of("Kevin","Kevin3@m.co","Kevin5@m.co","Kevin0@m.co"),\n                List.of("Ethan","Ethan5@m.co","Ethan4@m.co","Ethan0@m.co"),\n                List.of("Hanzo","Hanzo3@m.co","Hanzo1@m.co","Hanzo0@m.co"),\n                List.of("Fern","Fern5@m.co","Fern1@m.co","Fern0@m.co")\n        );\n\n        System.out.println(accountsMerge(accounts));\n        //Output: [["Ethan","Ethan0@m.co","Ethan4@m.co","Ethan5@m.co"],["Gabe","Gabe0@m.\n        //co","Gabe1@m.co","Gabe3@m.co"],["Hanzo","Hanzo0@m.co","Hanzo1@m.co","Hanzo3@m.\n        //co"],["Kevin","Kevin0@m.co","Kevin3@m.co","Kevin5@m.co"],["Fern","Fern0@m.co",\n        //"Fern1@m.co","Fern5@m.co"]]\n    }\n}\n'))))),(0,a.kt)("details",null,(0,a.kt)("summary",null," Alien Dictionary "),(0,a.kt)("h3",{id:"-see-leetcode-problem-269"},(0,a.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/alien-dictionary/"},"\u2197 See LeetCode Problem #269")),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},'import java.util.ArrayList;\nimport java.util.List;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n        private static Map<Character, List<Character>> reverseAdjListMap =\n                new HashMap<>();\n\n        private static Map<Character, Boolean> seenMap = new HashMap<>();\n\n        private static StringBuilder result = new StringBuilder();\n\n        static String alienOrder(String[] words) {\n\n            //   Step 0: Put all unique letters into reverseAdjListMap as keys\n            for (String word : words) {\n                for (char c : word.toCharArray()) {\n                    reverseAdjListMap.putIfAbsent(c, new ArrayList<>());\n                }\n            }\n\n            //  Step 1: Find all edges and add reverse edges to reverseAdjListMap\n            for (int i = 0; i < words.length - 1; i++) {\n\n                String word1 = words[i];\n                String word2 = words[i + 1];\n\n                // Check that word2 is not a prefix of word1.\n                if (word1.length() > word2.length() && word1.startsWith(word2)) {\n                    return "";\n                }\n\n                //  Find the first non-match and insert the corresponding relation\n                for (int j = 0; j < java.lang.Math.min(word1.length(), word2.length());\n                     j++){\n                    if (word1.charAt(j) != word2.charAt(j)) {\n                        reverseAdjListMap.get(word2.charAt(j)).add(word1.charAt(j));\n                        break;\n                    }\n                }\n            }\n\n            // Step 2: DFS to build up the result\n            for (Character c : reverseAdjListMap.keySet()) {\n                boolean flag = dfs(c);\n                if (!flag) return "";\n            }\n\n            return result.toString();\n        }\n\n        //   Return true if and only if no cycles detected\n        private static boolean dfs (Character c) {\n            if (seenMap.containsKey(c)) {\n                //  If this node was grey (false), a cycle was detected\n                return seenMap.get(c);\n            }\n            seenMap.put(c, false);\n\n            for (Character next : reverseAdjListMap.get(c)) {\n                boolean flag = dfs(next);\n                if (!flag) return false;\n            }\n            seenMap.put(c, true);\n\n            result.append(c);\n            return true;\n        }\n\n    public static void main(String[] args) {\n\n        // Example 1:\n        String[] words1 = {"wrt","wrf","er","ett","rftt"};\n        //  O/P: "wertf"\n\n        // Example 2:\n        String[] words2 = {"z","x"};\n        //  O/P: "zx"\n\n        // Example 3:\n        String[] words3 = {"z","x","z"};\n        //  O/P: ""\n\n        System.out.println(alienOrder(words1));\n//        System.out.println(alienOrder(words2));\n//        System.out.println(alienOrder(words3));\n\n    }\n}\n'))))),(0,a.kt)("details",null,(0,a.kt)("summary",null," Clone Graph "),(0,a.kt)("h3",{id:"-see-leetcode-problem-133"},(0,a.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/clone-graph/"},"\u2197 See LeetCode Problem #133")),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"// Needs to implement to toString method to see output\n// cloneGraph method works\n\nimport java.util.*;\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n\n    public Node(ArrayList<Node> _neighbors) {\n        neighbors = _neighbors;\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n\nclass Solution {\n/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\n//class Solution {\n    public static Node cloneGraph(Node node) {\n        if (node == null) {\n            return node;\n        }\n\n        //  HashMap/HashTable to map given (graph) node to the\n        //      cloned node as value\n        //  To avoid cycles and keep track of visited node\n        Map<Node, Node> visitedNodes = new HashMap<>();\n\n        //  Create a queue to make use a FIFO data structure\n        Queue<Node> bfsQueue = new LinkedList<>();\n\n        //  Add the given node as the first element of\n        //      the queue\n        bfsQueue.offer(node);\n\n        //  Add the given node as key, AND\n        //      its clone as value\n        visitedNodes.put(node, new Node(node.val, new ArrayList<>()));\n\n        //  while loop for BFS\n        while (!bfsQueue.isEmpty()) {\n\n            //  Remove and save the current node from the front\n            //      REMEMBER: First In First Out\n            Node currentNode = bfsQueue.poll();\n\n            //  Loop through all the neighbors\n            //     of the current node\n            for (Node currentNeighbor : currentNode.neighbors) {\n                //  Check if the map of visited nodes is empty\n                if (!visitedNodes.containsKey(currentNeighbor)) {\n                    //  If map not empty, add the current neighbor\n                    //      (and its clone) of the current node to the map\n                    visitedNodes.put(currentNeighbor,\n                            new Node(currentNeighbor.val, new ArrayList<>()));\n\n                    //  And, add current neighbor the queue\n                    bfsQueue.offer(currentNeighbor);\n                }\n\n                //  Update the cloned neighbors' list\n                //      using the current node\n                visitedNodes.get(currentNode).neighbors.add(\n                        visitedNodes.get(currentNeighbor));\n            }\n        }\n\n        //  Return the cloned node from the visitedNode map,\n        //      which is the value associated with the given node\n        //      put as key\n        return visitedNodes.get(node);\n    }\n\n    public static void main(String[] args) {\n\n        Node node1 = new Node(1, new ArrayList<>());\n        Node node2 = new Node(2, new ArrayList<>());\n        Node node3 = new Node(3, new ArrayList<>());\n        Node node4 = new Node(4, new ArrayList<>());\n        // Example 1:\n        // Input: adjList = [[2,4],[1,3],[2,4],[1,3]];\n        //  O/P: [[2,4],[1,3],[2,4],[1,3]]\n\n        node1.neighbors.add(node2);\n        node1.neighbors.add(node4);\n        node2.neighbors.add(node1);\n        node2.neighbors.add(node3);\n        node3.neighbors.add(node2);\n        node3.neighbors.add(node4);\n        node4.neighbors.add(node1);\n        node4.neighbors.add(node3);\n\n        System.out.println(cloneGraph(node1).val);\n        System.out.println(cloneGraph(node1).neighbors.get(0).val);\n        System.out.println(cloneGraph(node1).neighbors.get(1).val);\n\n        // Example 2:\n        //Input: adjList = [[]]\n        //  O/P: [[]]\n\n        Node nodeb1 = new Node(new ArrayList<>());\n        System.out.println(cloneGraph(nodeb1).val);\n\n        // Example 3:\n        //Input: adjList = []\n        //  O/P: []\n\n        Node nodec1 = new Node();\n        System.out.println(cloneGraph(nodec1).val);\n\n    }\n}\n"))))),(0,a.kt)("details",null,(0,a.kt)("summary",null," Course Schedule "),(0,a.kt)("h3",{id:"-see-leetcode-problem-207"},(0,a.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/course-schedule/"},"\u2197 See LeetCode Problem #207")),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"import java.util.*;\n\npublic class Solution {\n    public static boolean canFinish(int numCourses, int[][] prerequisites) {\n        List<Integer> sortedCourses = new ArrayList<>();\n        if (numCourses <= 0) {\n            return true;\n        }\n\n        //  Store nodes and (corresponing) counts of incoming edges\n        Map<Integer, Integer> incomingDegree = new HashMap<>();\n\n        //  Create Map to build an adjaceny list\n        Map<Integer, List<Integer>> adjacencyListMap = new HashMap<>();\n\n        for (int courseNode = 0; courseNode < numCourses; courseNode++) {\n            incomingDegree.put(courseNode, 0);\n            adjacencyListMap.put(courseNode, new ArrayList<>());\n        }\n\n        for (int courseNode = 0; courseNode < prerequisites.length;\n             courseNode++) {\n            int parentClass = prerequisites[courseNode][0];\n            int childClass = prerequisites[courseNode][1];\n            //  add childClass (prerequisite class) to the\n            //      value given as a ArrayList corresponding\n            //      to the parentClass marked as the key\n            adjacencyListMap.get(parentClass).add(childClass);\n            incomingDegree.put(childClass, incomingDegree.get(childClass) + 1);\n        }\n\n        //  Create a queue to add source nodes,\n        //     meaning nodes with 0 child/incomingDegree\n        Queue<Integer> nodeSources = new LinkedList<>();\n\n        for (Map.Entry<Integer, Integer> eSet : incomingDegree.entrySet()) {\n            if (eSet.getValue() == 0) {\n               nodeSources.add(eSet.getKey());\n            }\n        }\n\n        //  Add the source nodes to the sortedCourses ArrayList\n        while (!nodeSources.isEmpty()) {\n            int courseNode = nodeSources.poll();\n            sortedCourses.add(courseNode);\n\n            //  Decrease the courseNode's child/children's\n            //      incomingDegree map\n\n            //  Create the list of children nodes from the\n            //      adjacencyListMap\n            List<Integer> childrenNodes = adjacencyListMap.get(courseNode);\n            for (int childNode : childrenNodes) {\n                incomingDegree.put(childNode,\n                        incomingDegree.get(childNode) - 1);\n                if (incomingDegree.get(childNode) == 0){\n                    nodeSources.add(childNode);\n                }\n            }\n        }\n\n        if (sortedCourses.size() == numCourses) {\n            return true;\n        } else {\n             return false;\n        }\n\n    }\n\n    public static void main(String[] args) {\n        // Example 1:\n        int numCourses1 = 2;\n        int[][] prerequisites1 = {{1,0}};\n        //  O/P: true\n\n        // Example 2:\n        int numCourses2 = 2;\n        int[][] prerequisites2 = {{1,0},{0,1}};\n        //  O/P: false\n\n        // Example 3:\n        int numCourses3 = 0;\n        int[][] prerequisites3 = {{}};\n        //  O/P: false\n\n        System.out.println(canFinish(numCourses1, prerequisites1));\n        System.out.println(canFinish(numCourses2, prerequisites2));\n        System.out.println(canFinish(numCourses3, prerequisites3));\n\n    }\n}\n"))))),(0,a.kt)("details",null,(0,a.kt)("summary",null," Flood Fill "),(0,a.kt)("h3",{id:"-see-leetcode-problem-733"},(0,a.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/flood-fill/"},"\u2197 See LeetCode Problem #733")),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"import java.util.Arrays;\n\npublic class Solution {\n    static int[][] floodFill(int[][] image, int sr, int sc, int color) {\n\n        //  Optional, renaming the color to be used to replace\n        //      the existing color of the starting cell\n        int newColor = color;\n\n        //  Naming color of the starting cell\n        //  Since, color of the starting cell is to be replaced\n        //      calling it oldColor\n        int oldColor = image[sr][sc];\n\n        if (oldColor != newColor) {\n            floodFillDFSHelper(image, sr, sc, oldColor, newColor);\n        }\n\n        return image;\n    }\n\n    private static void floodFillDFSHelper(int[][] image,\n                                           int sr, int sc,\n                                           int oldColor,\n                                           int newColor) {\n\n        //  image.length: gives number of rows---row symbol: sr\n        //  image[0].length: gives number of columns---column symbol: sc\n        if (sr < 0 || sr >= image.length ||\n                sc < 0 || sc >= image[0].length) {\n            //  Since the conditions above do not represent\n            //      a valid cell\n            //  return statement is optional\n            //      goes back to the caller method\n            return;\n        }\n\n        //  Checks if the current cell has the same color\n        //      as the original color of the starting cell\n        if (image[sr][sc] != oldColor) {\n            //  return statement is optional\n            //      goes back to the caller method\n            return;\n        }\n\n        image[sr][sc] = newColor;\n\n        //  4-directional recursion calls\n        //  Vertical or Horizontal\n        //  NOT diagonal\n\n        //  Vertical Move: Up\n        floodFillDFSHelper(image, sr + 1, sc, oldColor, newColor);\n         //  Vertical Move: Down\n        floodFillDFSHelper(image, sr - 1, sc, oldColor, newColor);\n        //  Horizontal Move: Right\n        floodFillDFSHelper(image, sr, sc + 1, oldColor, newColor);\n        //  Horizontal Move: Left\n        floodFillDFSHelper(image, sr, sc - 1, oldColor, newColor);\n\n    }\n\n    public static void main(String[] args) {\n\n        // Example 1:\n        int[][] image1 = {{1,1,1},{1,1,0},{1,0,1}};\n        int sr1 = 1;\n        int sc1 = 1;\n        int color1 = 2;\n        //  O/P: [[2,2,2],[2,2,0],[2,0,1]]\n\n        // Example 2:\n        int[][] image2 = {{0,0,0},{0,0,0}};\n        int sr2 = 0;\n        int sc2 = 0;\n        int color2 = 0;\n        //  O/P: [[0,0,0],[0,0,0]]\n\n        System.out.println(Arrays.deepToString(floodFill(image1, sr1, sc1, color1)));\n        System.out.println(Arrays.deepToString(floodFill(image2, sr2, sc2, color2)));\n    }\n}\n"))))),(0,a.kt)("details",null,(0,a.kt)("summary",null," Minimum Height Trees "),(0,a.kt)("h3",{id:"-see-leetcode-problem-310"},(0,a.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/minimum-height-trees/"},"\u2197 See LeetCode Problem #310")),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},'import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic class Solution {\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        //  Time Complexity: O(v) where v is the number of nodes\n        //  Space Complexity: O(v) where v is the number of nodes\n        //  Pattern: Topological Sort\n        //  Pattern: Tree BFS\n        //      1. Test edge cases with n < 2, e.g. 0 or 1\n        //      2. Declare an ArrayList of (hash) sets to build\n        //          an adjacency list for the given tree/graph\n        //      3. Create an ArrayList to hold current leaf nodes\n        //              (nodes with only one edge)\n        //      4. Iterate over all the current leaf nodes and\n        //          remove them (and their corresponding edges)\n        //          from the list after processing is done;\n        //          this will expose new leaf nodes (if any) to be\n        //          processed in the next iteration\n        //      5. Iteration ends when # of unprocessed (available) nodes <= 2\n        //      6. NOTE: edges are preserved, at available nodes <= 2,\n        //          we have only one edge between two nodes\n\n        //  Test and deal with edge cases\n        if (n < 2) {\n            //  If n < 2 then all nodes are possible\n            //      root nodes of the minimum height trees\n            List<Integer> rootNodes = new ArrayList<>();\n\n            for (int i = 0; i < n; i++) {\n                rootNodes.add(i);\n            }\n\n            return rootNodes;\n        }\n\n        //  Declare an ArrayList of sets/hash sets\n        List<Set<Integer>> neighborNodes = new ArrayList<>();\n\n        //  Initialize the adjacency list by adding\n        //      n nodes with empty hash sets\n        for (int i = 0; i < n; i++) {\n            neighborNodes.add(new HashSet<>());\n        }\n\n        //  Connect the nodes with edges\n        for (int[] edge : edges) {\n            int startNode = edge[0];\n            int endNode = edge[1];\n\n            //  Since a tree is an undirected graph\n            //  Get the hash set at startNode from the neighborNodes list,\n            //      then add the endNode to the hash set\n            neighborNodes.get(startNode).add(endNode);\n            //  Get the hash set at endNode from the neighborNodes list,\n            //      then add the startNode to the hash set\n            neighborNodes.get(endNode).add(startNode);\n        }\n\n        //  Declare and initialize the first layer of leaf nodes\n        List<Integer> leafNodes = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            //  Create a test to find leaf nodes\n            //      with an if condition\n            //  Only one node in the hash set means one edge\n            if (neighborNodes.get(i).size() == 1) {\n                //  If leaf node, add it to the leafNode ArrayList\n                leafNodes.add(i);\n            }\n        }\n\n        //  Iterate over all the nodes until # of nodes <= 2\n        //      because\n\n        //  So, declare and intialize a variable to keep track of\n        //      nodes remaining available node\n        int nodesAvailable = n;\n\n        while (nodesAvailable > 2) {\n\n            //  Update nodesAvailable by subtracting current # of leaf nodes\n            nodesAvailable -= leafNodes.size();\n\n            //  Declare the next layer of leaf nodes\n            //      as an empty ArrayList\n            List<Integer> nextLeafNodes = new ArrayList<>();\n\n            for (int node : leafNodes) {\n\n                //  Find and store the next node neighbor\n                //      to the current leaf node using iterator\n                int nextNeighborNode =\n                        neighborNodes.get(node).iterator().next();\n\n                //  Now remove the current leaf node as\n                //      the neighbor of the nextNeighborNode,\n                //      since the current leaf node is being\n                //      processed in this iteration\n                neighborNodes.get(nextNeighborNode).remove(node);\n\n                //  Perform a test to find new leaf nodes\n                //      for next iteration with an if condition\n                if (neighborNodes.get(nextNeighborNode).size() == 1) {\n                    //  If leaf node, add it to the leafNode ArrayList\n                      nextLeafNodes.add(nextNeighborNode);\n                }\n\n                //  Update the leafNodes ArrayList for the\n                //      next iteration with nextLeafNodes\n                leafNodes = nextLeafNodes;\n                //  if nodesAvailable <= 2, updated leafNodes (nextLeafNodes)\n                //      won\'t participate in the next iteration.\n                //      Hence, the iteration stops here in that case\n\n            }\n        }\n\n        //  Remaning leaf nodes will be root nodes\n        //      of minimum height trees\n        return leafNodes;\n    }\n\n    public static void main(String[] args) {\n\n        Solution solution = new Solution();\n\n        // Example 1:\n        int n = 4;\n        int[][] edges = {{1,0},{1,2},{1,3}};\n        //  O/P: [1]\n        System.out.println(solution.findMinHeightTrees(n, edges));\n\n        System.out.println("---");\n        // Example 2:\n        n = 6;\n        edges = new int[][] {{3,0},{3,1},{3,2},{3,4},{5,4}};\n        //  O/P: [3,4]\n        System.out.println(solution.findMinHeightTrees(n, edges));\n    }\n}\n'))))),(0,a.kt)("details",null,(0,a.kt)("summary",null," Number of Islands "),(0,a.kt)("h3",{id:"-see-leetcode-problem-200"},(0,a.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/number-of-islands/"},"\u2197 See LeetCode Problem #200")),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Solution {\n    private static void visitedIslandsBFS(char[][] grid, int r, int c) {\n        Queue<int[]> visitedLands = new LinkedList<>();\n        visitedLands.add(new int[] {r, c});\n\n        while (!visitedLands.isEmpty()) {\n            int row = visitedLands.peek()[0];\n            int column = visitedLands.peek()[1];\n\n            //  Queue is FIFO:\n            //      first in first out\n            visitedLands.remove();\n\n            //  Check for valid cells\n            if (row < 0 || row >= grid.length ||\n                column < 0 || column >= grid[0].length) {\n                continue;\n            }\n            //  Check for water\n            if (grid[row][column] == '0') {\n                continue;\n            }\n\n            //  Mark as visited Land: switching land to water\n            grid[row][column] = '0';\n\n            //  Add adjacent cells horizontally or vertically\n            visitedLands.add(new int[] {row - 1, column }); //  move up 1 cell\n            visitedLands.add(new int[] {row + 1, column });  //  move down 1 cell\n            visitedLands.add(new int[] {row, column - 1});  //  move left 1 cell\n            visitedLands.add(new int[] {row, column + 1});  //  move right 1 cell\n        }\n    }\n\n    public static int numIslands(char[][] grid) {\n\n        if (grid == null || grid.length == 0) {\n            return 0;\n        }\n\n        int numberOfIslands = 0;\n\n        //   rowLength = grid.length;\n        for (int rowNum = 0; rowNum < grid.length; rowNum++) {\n            //  columnLength = grid[0].length;\n            for (int columnNum = 0; columnNum < grid[0].length; columnNum++) {\n                if (grid[rowNum][columnNum] == '1') {\n                    numberOfIslands++;\n                    visitedIslandsBFS(grid, rowNum, columnNum);\n                }\n            }\n        }\n        return numberOfIslands;\n    }\n\n    public static void main(String[] args) {\n        // Example 1:\n        char[][] grid1 = {\n                            {'1','1','1','1','0'},\n                            {'1','1','0','1','0'},\n                            {'1','1','0','0','0'},\n                            {'0','0','0','0','0'}\n                        };\n        //  O/P: 1\n\n        // Example 2:\n        char[][] grid2 = {\n                            {'1','1','0','0','0'},\n                            {'1','1','0','0','0'},\n                            {'0','0','1','0','0'},\n                            {'0','0','0','1','1'}\n                        };\n        //  O/P: 3\n\n        System.out.println(numIslands(grid1));\n        System.out.println(numIslands(grid2));\n    }\n}\n"))))),(0,a.kt)("details",null,(0,a.kt)("summary",null," Rotting Oranges "),(0,a.kt)("h3",{id:"-see-leetcode-problem-994"},(0,a.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/rotting-oranges/"},"\u2197 See LeetCode Problem #994")),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Solution {\n    public static int orangesRotting(int[][] grid) {\n        //  If grid is null or empty return 0\n        //      since there are no fresh orange\n        //      and no time is elapsed\n        if (grid == null || grid.length == 0) {\n            return 0;\n        }\n\n        //  row indexed from top to bottom\n        int bottomBoundary = grid.length;\n\n        //  column indexed from left to right\n        int rightBoundary = grid[0].length;\n\n        //  Declare a queue to store the (row, column)\n        //      coordinates of all the rotten oranges\n        Queue<int[]> bfsQueue = new LinkedList<>();\n\n        //  Declare and initialize a variable\n        //      to count all the fresh oranges\n        int freshCount = 0;\n\n        //  Iterate over all the grid points/cells\n        //      to find and store the rotten oranges\n        //      in a queue\n        for (int i = 0; i < bottomBoundary; i++) {\n            for (int j = 0; j < rightBoundary; j++) {\n                if (grid[i][j] == 2) {\n                    bfsQueue.offer(new int[] {i, j});\n                } else if (grid[i][j] == 1) {\n                    //  If fresh increae the count of\n                    //      fresh oranges by 1\n                    freshCount++;\n                }\n            }\n        }\n\n        //  If there are no fresh oranges even\n        //      at the beginning, return 0\n        if (freshCount == 0) {\n            return 0;\n        }\n\n        //  Declare and initialize a variable\n        //      to count elapsed time\n        int timeCount = 0;\n\n        //  Declare and define a 2D array to\n        //      mark boundary of each BFS step\n        //\n        //      {-1, 0} : out of bound (row) cell/point\n        //      {0, 1}  : right cell/point\n        //      {1, 0}  : lower cell/point\n        //      {0, -1} : out of bound (column) cell/point\n        int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n\n        //  Iterate over all entries in the bfsQueue\n        //      to check the number of fresh oranges\n        //      and elapsed time until the bfsQueue is empty\n        while (!bfsQueue.isEmpty()) {\n            //  Increase the timeCound by 1\n            timeCount++;\n\n            //  Store the size of bfsQueue\n            //      efficient time management\n            //      and keeping the current size unchanged\n            int queueSize = bfsQueue.size();\n\n            //  Iterate over all bfsQueue entries\n            //      one step at a time\n            for (int i = 0; i < queueSize; i++) {\n                //  Remove and store the current cell/point\n                int[] currentCell = bfsQueue.poll();\n\n                //  Update the current cell consider\n                //      for possible directions\n                for (int[] direction : directions ) {\n                    int newRow = currentCell[0] + direction[0];\n                    int newColumn = currentCell[1] + direction[1];\n\n                    //  Ignore/continue if\n                    //      newRow/newColumn is out of bound\n                    //      or, cell is empty\n                    //      or, orange at the new cell is already rotten\n                    if (newRow < 0 || newColumn < 0     ||\n                        newRow >= bottomBoundary        ||\n                        newColumn >= rightBoundary      ||\n                        grid[newRow][newColumn] == 0    ||\n                        grid[newRow][newColumn] == 2) {\n                        continue;\n                    }\n\n                    //  Mark the new cell as rotten\n                    grid[newRow][newColumn] = 2;\n\n                    //  Add the new cell in the queue\n                    bfsQueue.offer(new int[] {newRow, newColumn});\n\n                    //  Decrease the count of fresh oranges\n                    freshCount--;\n                }\n            }\n        }\n        //  Using a ternary operator return\n        //      -1 if there are still fresh oranges remaining\n        //      or, elapsed time if there are no rotten oranges\n        //      remaining (in latter case decrease timeCount by 1\n        //      since, timeCount is increased at the very beginning\n        //      of the iteration (at timestep 0)\n        return freshCount == 0 ? timeCount - 1 : -1;\n    }\n\n    public static void main(String[] args) {\n        // Example 1:\n        int[][] grid1 = {{2,1,1},{1,1,0},{0,1,1}};\n        //  O/P: 4\n\n        // Example 2:\n        int[][] grid2 = {{2,1,1},{0,1,1},{1,0,1}};\n        //  O/P: -1\n\n        // Example 3:\n        int[][] grid3 = {{0,2}};\n        //  O/P: 0\n\n        System.out.println(orangesRotting(grid1));\n        System.out.println(orangesRotting(grid2));\n        System.out.println(orangesRotting(grid3));\n\n    }\n}\n"))))),(0,a.kt)("details",null,(0,a.kt)("summary",null," Word Ladder "),(0,a.kt)("h3",{id:"-word-ladder"},(0,a.kt)("a",{parentName:"h3",href:"/dsa/docs/data-structures/e-hash-sets"},"\u2197 Word Ladder"))),(0,a.kt)("details",null,(0,a.kt)("summary",null," Word Search "),(0,a.kt)("h3",{id:"-see-leetcode-problem-79"},(0,a.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/word-search/"},"\u2197 See LeetCode Problem #79")),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"public class Solution {\n    /**\n     * TIME COMPLEXITY: O(n 3^l) where n is the number of grid cells and\n     *      l is the length of the given word\n     * SPACE COMPLEXITY: O(l) where l is the length of the given word\n     *\n     * STEPS\n     * ---------------------\n     * 1. Begin the search with the first character of the given word;\n     *      that is, from index 0 as in word.chaAt(0)\n     * 2. Using a backtrackHelper function:\n     *      2.1 Check base cases #1, #2, and #3 (see code below)\n     *      2.2. Search horizontally (in 2 directions) and\n     *          vertically (in 2 more directions);\n     *          however, 3 directions in total in each iteration\n     *          since sequential and not moving back to the starting point\n     *\n     * 3. Declare a boolean flag to return and\n     *      mark place '0' in the current cell to mark it as visited\n     * 4. Finally, return the flag\n     */\n\n    //  Grid of characters\n    private char[][] board;\n    //  Length of rows\n    private int rowLength;\n    //  Length of columns\n    private int colLength;\n\n    /**\n     * @param board given grid of characters\n     * @param word  given word\n    */\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        this.rowLength = board.length;\n        this.colLength = board[0].length;\n\n        for (int row = 0; row < rowLength; row++) {\n            for (int col = 0; col < colLength; col++) {\n                //  index = 0 since starting from\n                //      the beginning of the word every time\n                if (this.backtrackHelper(row, col, word, 0)) {\n                    return true;\n                }\n            }\n        }\n\n        //  return false if word not found\n        return false;\n    }\n\n    /**\n     * @param r     row #\n     * @param c     column #\n     * @param w     given word\n     * @param idx   index as in word.charAt(index)\n    */\n    private boolean backtrackHelper (int r, int c, String w, int idx) {\n\n        //  Check base case #1:\n        //      return true if current index\n        //      is equal to the length of the word\n        if (idx == w.length()) {\n            return true;\n        }\n\n        //  Check base case #2:\n        //      return false if row or colum #\n        //      falls behind the bounadaries\n        if (r < 0 || r == this.rowLength || c < 0 || c == this.colLength) {\n            return false;\n        }\n\n        //  Check base case #3:\n        //      return false if the first character of the given\n        //      word is not the same as the one in the current cell\n        if (this.board[r][c] != w.charAt(idx)) {\n            return false;\n        }\n\n        //  Declare a boolean flag and initialize it with false\n        boolean flag = false;\n\n        //  Mark the visited cell with an arbitrary value,\n        //      for example = 0;\n        this.board[r][c] = '0';\n\n        //  Declare a 2D direction matrix\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n        //  Iterate over the possible directions\n        for (int[] d : directions) {\n            flag = this.backtrackHelper(r + d[0],\n                                        c + d[1],\n                                        w, idx + 1);\n\n            if(flag) {\n                break;\n            }\n        }\n\n        //  Update the current cell by replacing 0 with\n        //      the original character\n        this.board[r][c] = w.charAt(idx);\n        return flag;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Example 1:\n        char[][] board1 = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};\n        String word1 = \"ABCCED\";\n        System.out.println(solution.exist(board1, word1));\n        //  O/P: true\n\n        System.out.println();\n        // Example 2:\n        char[][] board2 = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};\n        String word2 = \"SEE\";\n        //  O/P: true\n        System.out.println(solution.exist(board2, word2));\n\n        System.out.println();\n        // Example 3:\n        char[][] board3 = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};\n        String word3 = \"ABCB\";\n\n        System.out.println(solution.exist(board3, word3));\n        //  O/P: false\n    }\n}\n"))))),(0,a.kt)("details",null,(0,a.kt)("summary",null," 01 Matrix "),(0,a.kt)("h3",{id:"-see-leetcode-problem-542"},(0,a.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/01-matrix/"},"\u2197 See LeetCode Problem #542")),(0,a.kt)(i.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"import java.util.Arrays;\n\npublic class Solution {\n    public static int[][] updateMatrix(int[][] mat) {\n\n        if (mat.length == 0 || mat[0].length == 0) {\n            return mat;\n        }\n\n        int[][] distMatrix = new int[mat.length][mat[0].length];\n\n        //  Set Integer.MAX_VALUE / 2 as cell values\n        //      Divided by 2 to avoid Integer Overflow\n        for (int i = 0; i < mat.length; i++) {\n            for (int j = 0; j < mat[0].length; j++) {\n                distMatrix[i][j] = Integer.MAX_VALUE / 2;\n            }\n        }\n\n        //  Left & Top/Up\n        //  From top to bottom and left to right\n        //  To check left and top directions\n        for (int i = 0; i < mat.length; i++) {\n            for (int j = 0; j < mat[0].length; j++) {\n                if (mat[i][j] == 0) {\n                    distMatrix[i][j] = 0;\n                } else {\n                    if (i > 0) {\n                        distMatrix[i][j] = Math.min(\n                                distMatrix[i][j],\n                                distMatrix[i - 1][j]) + 1;\n                    }\n\n                    if (j > 0) {\n                        distMatrix[i][j] = Math.min(\n                                distMatrix[i][j],\n                                distMatrix[i][j - 1]) + 1;\n                    }\n                }\n            }\n        }\n\n        //  Down/Bottom & Right\n        //  From Bottom to top and right to left\n        //  To check right and bottom directions\n        for (int i = mat.length - 1; i >=0 ; i--) {\n            for (int j = mat[0].length - 1; j >=0 ; j--) {\n                if (i < mat.length - 1) {\n                    distMatrix[i][j] = Math.min (\n                            distMatrix[i][j],\n                            distMatrix[i + 1][j]) + 1;\n                }\n\n                if (j < mat[0].length - 1) {\n                    distMatrix[i][j] = Math.min (\n                            distMatrix[i][j],\n                            distMatrix[i][j + 1]) + 1;\n                }\n            }\n        }\n\n        return distMatrix;\n    }\n\n    public static void main(String[] args) {\n        // Example 1:\n        int[][] mat1 = {{0,0,0},{0,1,0},{0,0,0}};\n        //Output: [[0,0,0],[0,1,0],[0,0,0]]\n\n        // Example 2:\n        int[][] mat2 = {{0,0,0},{0,1,0},{1,1,1}};\n        //Output: [[0,0,0],[0,1,0],[1,2,1]]\n\n        // Example 3A:\n        int[][] mat3a = {{0},{0},{0}};\n        //Output: [[0],[0],[0]]\n\n        // Example 3B:\n        int[][] mat3b = {{0},{1},{0}};\n        //Output: [[0],[1],[0]]\n\n        // Example 4:\n        int[][] mat4 = {{0,0,0}};\n        //Output: [[0],[0],[0]]\n\n        // Example 5:\n        int[][] mat5 = {{0}};\n        //Output: [[0]]\n\n        // Example 6:\n        int[][] mat6 = {{}};\n        //Output: [[]]\n\n        // Example 6:\n        int[][] mat7 = {{1,1,0,0,1,0,0,1,1,0},\n                        {1,0,0,1,0,1,1,1,1,1},\n                        {1,1,1,0,0,1,1,1,1,0},\n                        {0,1,1,1,0,1,1,1,1,1},\n                        {0,0,1,1,1,1,1,1,1,0},\n                        {1,1,1,1,1,1,0,1,1,1},\n                        {0,1,1,1,1,1,1,0,0,1},\n                        {1,1,1,1,1,0,0,1,1,1},\n                        {0,1,0,1,1,0,1,1,1,1},\n                        {1,1,1,0,1,0,1,1,1,1}};\n\n        //  Time Complexity: O(r*c)\n        //  Space Complexity: O(1)\n\n        System.out.println(Arrays.deepToString(updateMatrix(mat1)));\n        System.out.println(Arrays.deepToString(updateMatrix(mat2)));\n        System.out.println(Arrays.deepToString(updateMatrix(mat3a)));\n        System.out.println(Arrays.deepToString(updateMatrix(mat3b)));\n        System.out.println(Arrays.deepToString(updateMatrix(mat4)));\n        System.out.println(Arrays.deepToString(updateMatrix(mat5)));\n        System.out.println(Arrays.deepToString(updateMatrix(mat6)));\n        System.out.println(Arrays.deepToString(updateMatrix(mat7)));\n\n    }\n}\n"))))))}h.isMDXComponent=!0}}]);