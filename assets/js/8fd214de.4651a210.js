"use strict";(self.webpackChunkdsa=self.webpackChunkdsa||[]).push([[8493],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>c});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=u(t),c=r,h=p["".concat(l,".").concat(c)]||p[c]||m[c]||i;return t?a.createElement(h,s(s({ref:n},d),{},{components:t})):a.createElement(h,s({ref:n},d))}));function c(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,s=new Array(i);s[0]=p;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var u=2;u<i;u++)s[u]=t[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},5162:(e,n,t)=>{t.d(n,{Z:()=>s});var a=t(7294),r=t(6010);const i="tabItem_Ymn6";function s(e){let{children:n,hidden:t,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(i,s),hidden:t},n)}},5488:(e,n,t)=>{t.d(n,{Z:()=>c});var a=t(7462),r=t(7294),i=t(6010),s=t(2389),o=t(7392),l=t(7094),u=t(2466);const d="tabList__CuJ",m="tabItem_LNqP";function p(e){var n;const{lazy:t,block:s,defaultValue:p,values:c,groupId:h,className:f}=e,y=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),b=c??y.map((e=>{let{props:{value:n,label:t,attributes:a}}=e;return{value:n,label:t,attributes:a}})),v=(0,o.l)(b,((e,n)=>e.value===n.value));if(v.length>0)throw new Error(`Docusaurus error: Duplicate values "${v.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const k=null===p?p:p??(null==(n=y.find((e=>e.props.default)))?void 0:n.props.value)??y[0].props.value;if(null!==k&&!b.some((e=>e.value===k)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${k}" but none of its children has the corresponding value. Available values are: ${b.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:g,setTabGroupChoices:x}=(0,l.U)(),[w,N]=(0,r.useState)(k),L=[],{blockElementScrollPositionUntilNextRender:P}=(0,u.o5)();if(null!=h){const e=g[h];null!=e&&e!==w&&b.some((n=>n.value===e))&&N(e)}const S=e=>{const n=e.currentTarget,t=L.indexOf(n),a=b[t].value;a!==w&&(P(n),N(a),null!=h&&x(h,String(a)))},T=e=>{var n;let t=null;switch(e.key){case"ArrowRight":{const n=L.indexOf(e.currentTarget)+1;t=L[n]??L[0];break}case"ArrowLeft":{const n=L.indexOf(e.currentTarget)-1;t=L[n]??L[L.length-1];break}}null==(n=t)||n.focus()};return r.createElement("div",{className:(0,i.Z)("tabs-container",d)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":s},f)},b.map((e=>{let{value:n,label:t,attributes:s}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:w===n?0:-1,"aria-selected":w===n,key:n,ref:e=>L.push(e),onKeyDown:T,onFocus:S,onClick:S},s,{className:(0,i.Z)("tabs__item",m,null==s?void 0:s.className,{"tabs__item--active":w===n})}),t??n)}))),t?(0,r.cloneElement)(y.filter((e=>e.props.value===w))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},y.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==w})))))}function c(e){const n=(0,s.Z)();return r.createElement(p,(0,a.Z)({key:String(n)},e))}},9490:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>u,toc:()=>m});var a=t(7462),r=(t(7294),t(3905)),i=t(5488),s=t(5162);const o={sidebar_position:8,id:"h-heaps",title:"Heaps",tags:["heaps","find-median-from-data-stream","k-closest-point-to-origin","merge-k-sorted-lists","task-scheduler"]},l="Heaps",u={unversionedId:"data-structures/h-heaps",id:"data-structures/h-heaps",title:"Heaps",description:"- Understanding heaps",source:"@site/docs/data-structures/h-heaps.md",sourceDirName:"data-structures",slug:"/data-structures/h-heaps",permalink:"/dsa/docs/data-structures/h-heaps",draft:!1,tags:[{label:"heaps",permalink:"/dsa/docs/tags/heaps"},{label:"find-median-from-data-stream",permalink:"/dsa/docs/tags/find-median-from-data-stream"},{label:"k-closest-point-to-origin",permalink:"/dsa/docs/tags/k-closest-point-to-origin"},{label:"merge-k-sorted-lists",permalink:"/dsa/docs/tags/merge-k-sorted-lists"},{label:"task-scheduler",permalink:"/dsa/docs/tags/task-scheduler"}],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8,id:"h-heaps",title:"Heaps",tags:["heaps","find-median-from-data-stream","k-closest-point-to-origin","merge-k-sorted-lists","task-scheduler"]},sidebar:"docs",previous:{title:"Queues",permalink:"/dsa/docs/data-structures/g-queues"},next:{title:"Binary Search Trees",permalink:"/dsa/docs/data-structures/i-binary-search-trees"}},d={},m=[{value:"Problems related to heaps",id:"problems-related-to-heaps",level:2},{value:"\u2197 See LeetCode Problem #295",id:"-see-leetcode-problem-295",level:3},{value:"\u2197 See LeetCode Problem #973",id:"-see-leetcode-problem-973",level:3},{value:"\u2197 See LeetCode Problem #23",id:"-see-leetcode-problem-23",level:3},{value:"\u2197 See LeetCode Problem #621",id:"-see-leetcode-problem-621",level:3}],p={toc:m};function c(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"heaps"},"Heaps"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Understanding heaps "),(0,r.kt)("li",{parentName:"ul"},"Solved problems are presented in alphabetical order")),(0,r.kt)("h2",{id:"problems-related-to-heaps"},"Problems related to heaps"),(0,r.kt)("details",null,(0,r.kt)("summary",null," Find Median from Data Stream "),(0,r.kt)("h3",{id:"-see-leetcode-problem-295"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/find-median-from-data-stream/"},"\u2197 See LeetCode Problem #295")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},'import java.util.Comparator;\nimport java.util.PriorityQueue;\n\npublic class Solution {\n//class MedianFinder {\n\n    //  maxHeap for upper half (w/ lower value) of the stream\n    //      for example,\n    //      9 8 7 6 5 4\n    PriorityQueue<Integer> maxHeap = null;\n\n    //  minHeap for lower half (w/ lower value) of the stream\n    //      for example,\n    //      10 11 12 13 14 15\n    PriorityQueue<Integer> minHeap = null;\n\n    //  Initialize the data structures\n    public Solution () {\n        minHeap = new PriorityQueue<>();\n        maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\n    }\n\n    public void addNum(int num) {\n        minHeap.offer(num);\n        maxHeap.offer(minHeap.poll());\n\n        if (minHeap.size() < maxHeap.size()) {\n            minHeap.offer(maxHeap.poll());\n        }\n    }\n\n    public double findMedian() {\n        if (minHeap.size() > maxHeap.size()) {\n            return minHeap.peek();\n        } else {\n            return (minHeap.peek() + maxHeap.peek()) / 2.0;\n        }\n    }\n\n    public static void main(String[] args) {\n\n        // Example 1:\n        //Input\n        //["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]\n        //[[], [1], [2], [], [3], []]\n        //Output\n        //[null, null, null, 1.5, null, 2.0]\n\n        //  Solution instead of MedianFinder since Solution is class name\n        Solution medianFinder = new Solution();\n        medianFinder.addNum(1);    // arr = [1]\n        medianFinder.addNum(2);    // arr = [1, 2]\n        medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\n        System.out.println(medianFinder.findMedian());\n        medianFinder.addNum(3);    // arr[1, 2, 3]\n        medianFinder.findMedian(); // return 2.0\n        System.out.println(medianFinder.findMedian());\n\n    }\n}\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder obj = new MedianFinder();\n * obj.addNum(num);\n * double param_2 = obj.findMedian();\n */\n'))))),(0,r.kt)("details",null,(0,r.kt)("summary",null," K Closest Points to Origin "),(0,r.kt)("h3",{id:"-see-leetcode-problem-973"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/k-closest-points-to-origin/"},"\u2197 See LeetCode Problem #973")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"import java.util.Queue;\nimport java.util.PriorityQueue;\nimport java.util.Arrays;\n\npublic class Solution {\n    public static int[][] kClosest(int[][] points, int k) {\n\n        //  Declare the output 2D array\n        //  1st []: k number of rows\n        //  2nd []: 2 colums\n        int[][] result2DArray = new int[k][2];\n\n        //  Declare maximum Heap with PriorityQueue Class\n        //      using (x2 * x2) + (y2 * y2) - (x1 * x1) - (y1 * y1)\n        //      instead of using\n        //      sqrt((x2 * x2) + (y2 * y2)) - sqrt(((x1 * x1) + (y1 * y1))\n        //      to compare the distances from origin\n        Queue<int[]> maxHeap = new PriorityQueue<>((p1, p2) ->\n                (p2[0] * p2[0]) + (p2[1] * p2[1])\n                - (p1[0] * p1[0]) - (p1[1] * p1[1]));\n\n        //  Add all points (as int arrays) to maxHeap\n        //  Poll to remove all points if maxHeap has more\n        //      than k points (of type int[]),\n        //      which automatically removes points\n        //      larger (hence maximum heap) distances\n        //      from the heap data structure\n        //   Since, maxHeap has maximum values on top\n        for (int [] point : points) {\n            maxHeap.offer(point);\n            if (maxHeap.size() > k) {\n                maxHeap.poll();\n            }\n        }\n\n        //  Poll to save points in already defined\n        //      result2DArray\n        //  --k is precrement:\n        //      it first decreases the k by 1 and then\n        //      applies the decreased value as result2DArray index\n        //      to store polled array at the decreased index\n        //  k > 0: means the very last k = 1;\n        //      so, the very last --k = 0;\n        //      therefore, result2DArray fills from the end index\n        //      to the start index\n        while (k > 0) {\n            result2DArray[--k] = maxHeap.poll();\n        }\n\n        return result2DArray;\n    }\n\n    public static void main(String[] args) {\n        // Example 1:\n        int[][] points1 = {{1,3},{-2,2}};\n        int k1 = 1;\n        //  O/P: [[-2,2]]\n\n        // Example 2:\n        int[][] points2 = {{3,3},{5,-1},{-2,4}};\n        int k2 = 2;\n        //  O/P: [[3,3],[-2,4]]\n\n        System.out.println(Arrays.deepToString(kClosest(points1, k1)));\n        System.out.println(Arrays.deepToString(kClosest(points2, k2)));\n\n    }\n}\n"))))),(0,r.kt)("details",null,(0,r.kt)("summary",null," Merge k Sorted Lists "),(0,r.kt)("h3",{id:"-see-leetcode-problem-23"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/merge-k-sorted-lists/"},"\u2197 See LeetCode Problem #23")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\nclass ListNode {\n//    int data;\n    int val;\n    ListNode next;\n\n    ListNode (int data) {\n//        this.data = data;\n        this.val = data;\n    }\n}\n\npublic class Solution {\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n//class Solution {\n//     static ListNode mergeKLists(ListNode[] lists) {\n    static int mergeKLists(ListNode[] lists) {\n\n        Comparator<ListNode> cmp;\n        cmp = new Comparator<ListNode>() {\n            @Override\n            public int compare(ListNode o1, ListNode o2) {\n                return o1.val - o2.val;\n            }\n        };\n\n        Queue<ListNode> q = new PriorityQueue<ListNode>(cmp);\n\n        for (ListNode l : lists) {\n            if (l != null) {\n                q.add(l);\n            }\n        }\n\n        ListNode head = new ListNode(0);\n        ListNode point = head;\n\n        while (!q.isEmpty()) {\n            point.next = q.poll();\n            point = point.next;\n            ListNode next = point.next;\n\n            if (next != null) {\n                q.add(next);\n            }\n        }\n\n//        return head.next;\n        return head.next.val;\n    }\n\n    public static void main(String[] args) {\n\n        // Example 1:\n        int[][] arrayLists = {{1,4,5},{1,3,4},{2,6}};\n        //  O/P: [1,1,2,3,4,4,5,6]\n\n        int[] dataArray1 = arrayLists[0];\n        int[] dataArray2 = arrayLists[1];\n        int[] dataArray3 = arrayLists[2];\n\n        ListNode head1 = new ListNode(dataArray1[0]);\n        ListNode current1 = head1;\n\n        ListNode head2 = new ListNode(dataArray2[0]);\n        ListNode current2 = head2;\n\n        ListNode head3 = new ListNode(dataArray3[0]);\n        ListNode current3 = head3;\n\n        for (int i = 1; i < dataArray1.length; i++) {\n\n            ListNode node = new ListNode(dataArray1[i]);\n\n            current1.next = node;\n            current1 = node;\n        }\n\n        for (int i = 1; i < dataArray2.length; i++) {\n\n            ListNode node = new ListNode(dataArray1[i]);\n\n            current2.next = node;\n            current2 = node;\n        }\n\n        for (int i = 1; i < dataArray3.length; i++) {\n\n            ListNode node = new ListNode(dataArray3[i]);\n\n            current3.next = node;\n            current3 = node;\n        }\n\n        ListNode[] lists = {head1, head2, head3};\n\n        // Example 2:\n//        int[] lists = []\n        //  O/P: []\n\n        // Example 3:\n//        int[] lists = [[]]\n        //  O/P: []\n\n        System.out.println(mergeKLists(lists));\n\n    }\n}\n"))))),(0,r.kt)("details",null,(0,r.kt)("summary",null," Task Scheduler "),(0,r.kt)("h3",{id:"-see-leetcode-problem-621"},(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/task-scheduler/"},"\u2197 See LeetCode Problem #621")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},"public class Solution {\n    public static int leastInterval(char[] tasks, int n) {\n        //  There are two ways we need to consider\n        //      to find the least number of units times\n        //      that CPU will take to finish all the given tasks\n\n        //  Way 1:  # of most repeating type(s) of task is NOT\n        //          frequent enough to require idle CPU cycle.\n        //          In this case length of tasks array gives the\n        //          answer (required least number of unit times)\n\n        //  Way 2:  # of most repeating type(s) of task IS\n        //          frequent enough to require idle CPU cycle.\n        //          In this case, the answer (required least number of unit times)\n        //          is obtained using the following expression\n        //          (1 + n) * (freqMax - 1) + numOfTasksWithFreqMax\n        //          where n = cooldown period between two tasks of same type\n        //                    given n units of time\n        //          It works because 1 + n gives the time for each task\n        //          (w/ max frequency) plus the cooling period\n        //          So, 1 + n needs to be mulitplied by the (max frequency - 1)\n        //          Then, we will need add all tasks that have max frequency\n        //          Henc, 1 was subtracted from max frequency in the earlier calculation\n\n        //  So, maximum of Way 1 and Way 2 is the required answer\n        //  Because, idle CPU times should add to the length of tasks array\n        //      if there aren't enough tasks to fill the idle CPU cycles\n\n        //  Way 1\n        int tasksLength = tasks.length;\n\n        //  Way 2\n\n        //  Declare the array with frequencies\n        //  Intialize with 26 elements with default values of 0s\n        //      for 26 uppercase English letters\n        int[] frequenciesArray = new int[26];\n\n        //  Build the array with frequencies\n        for (char task : tasks) {\n            //  Subtracting character 'A' from given\n            //  task/character makes it 0-indexed\n            //  Given, all tasks are given in uppercase letters\n            frequenciesArray[task - 'A']++;\n        }\n\n        //  Find the maximum frequency from the array w/ frequencies\n        //  Declare and initialize the maximum frequency\n        int maxFrequency = 0;\n\n        for (int frequency : frequenciesArray) {\n            maxFrequency = Math.max(maxFrequency, frequency);\n        }\n\n        //  Count the number of task(s) w/ maxFrequency\n        //  Declare and initialize the numMaxFrequencyTasks\n        int  numMaxFrequencyTasks = 0;\n\n        for (int frequency : frequenciesArray) {\n            if (frequency == maxFrequency) {\n                numMaxFrequencyTasks++;\n            }\n        }\n\n        return Math.max(tasksLength,\n                ((1 + n) * (maxFrequency - 1) + numMaxFrequencyTasks));\n    }\n\n    public static void main(String[] args) {\n        // Example 1:\n        char[] tasks1 = {'A','A','A','B','B','B'};\n        int n1 = 2;\n        //  O/P: 8\n\n        // Example 2:\n        char[] tasks2 = {'A','A','A','B','B','B'};\n        int n2 = 0;\n        //  O/P: 6\n\n        // Example 3:\n        char[] tasks3 = {'A','A','A','A','A','A','B','C','D','E','F','G'};\n        int n3 = 2;\n        //  O/P: 16\n\n        System.out.println(leastInterval(tasks1, n1));\n        System.out.println(leastInterval(tasks2, n2));\n        System.out.println(leastInterval(tasks3, n3));\n\n    }\n}\n"))))))}c.isMDXComponent=!0}}]);